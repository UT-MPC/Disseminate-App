package ut.beacondisseminationapp.common;

import java.util.NoSuchElementException;
import java.util.Timer;
import java.util.TimerTask;

import subscription.SendSubscription;
import mobile.HostMain;
import mobile.MobileHost;

public class SourceTask extends TimerTask {

	//private boolean needToCancel = false;
	@Override
	public void run() {
		downloadChunk();
		selectNextChunk();
		
	}
	
	private void downloadChunk() {
		//System.out.println("Received virtual chunk!");
		Chunk vChunk = MobileHost.virtualChunk;
		
		// get the item associated with the virtual chunk
		Item curItem = MobileHost.items.get(vChunk.itemId);
		
		if (curItem.bv.testBit(vChunk.chunkId)) { // check to see if we already have it
			(curItem.discardedVirtual)++;
		} else {
			if (curItem.startTime == 0) {
				curItem.startTime = System.currentTimeMillis();
			}
			(curItem.receivedVirtual)++;
			curItem.bv.setBit(vChunk.chunkId); // set the bit for the received chunk
			if (curItem.isCompleted()) {
				if (curItem.completedTime == 0) {
					curItem.completedTime = System.currentTimeMillis();
				}
				System.out.println("Completed an item: "+curItem.name);
			}
		}
		MobileHost.items.put(vChunk.itemId, curItem);
		MobileHost.myBeacon.bvMap.put(vChunk.itemId, curItem.bv);
		(new Timer()).schedule(new SendSubscription(), 0);
		//System.out.println("Virtual Rate: "+MobileHost.getRate((curItem.discardedVirtual+curItem.receivedVirtual)*curItem.chunkSize,System.currentTimeMillis(),curItem.startTime)+ "KBytes/Sec");
	}

	private void selectNextChunk() {
		
		Chunk vChunk = MobileHost.virtualChunk;
		
		// get the item associated with the virtual chunk
		Item curItem = MobileHost.items.get(vChunk.itemId);

		// check if the item is completed
		while (curItem.isCompleted()) { // repeat
			//needToCancel = true;
			int indexNextItem = 0;
			try {
				indexNextItem = MobileHost.curItemItr.next();
			} catch (NoSuchElementException e) {
				HostMain.sourceTimer.cancel();
				return;
			}
			curItem = MobileHost.items.get("item"+indexNextItem);
			if (curItem.startTime == 0) {
				curItem.startTime = System.currentTimeMillis();
			}
			vChunk = new Chunk(curItem.name, 0, curItem.chunkSize, "");
		}
		
		while (curItem.bv.testBit(vChunk.chunkId)) { // check if we have this chunk
			vChunk.chunkId++;
			if (vChunk.chunkId >= Utility.NUM_CHUNKS) { // if this is the last chunk and we have it, we must have the whole item
				// item iteration runs in here to handle race condition, where item is completed in the time between the two loops
				while (curItem.isCompleted()) { // repeat
					//needToCancel = true;
					int indexNextItem = 0;
					try {
						indexNextItem = MobileHost.curItemItr.next();
					} catch (NoSuchElementException e) {
						HostMain.sourceTimer.cancel();
						return;
					}
					curItem = MobileHost.items.get("item"+indexNextItem);
					//curItem.startTime = System.currentTimeMillis();
				}	
			}
		}
		
		// Assign the next virtual chunk for download
		MobileHost.virtualChunk = vChunk;
		
		/*if (needToCancel) {
			needToCancel = false;
			HostMain.sourceTimer.cancel();
			HostMain.sourceTimer = new Timer();
			HostMain.sourceTimer.scheduleAtFixedRate(new SourceTask(), 0, MobileHost.sourceRate(curItem.chunkSize));
		}*/
		MobileHost.items.put(vChunk.itemId, curItem);
	}
}
