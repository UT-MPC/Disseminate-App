package mobile;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.MulticastSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;

import common.Chunk;
import common.Need;
import common.Utility;
import network.TcpReceiver;

public class MobileMainTcp {

	private static final int LPORT = 9000;
	
	public static void main(String args[]) {
		
		//HashMap test
		/*
		HashMap<Integer, Integer> testMap = new HashMap<Integer,Integer>();
		testMap.put(5, 24);
		Integer tempInt = testMap.get(5);
		tempInt += 1;
		System.out.println("tempInt: "+testMap.get(5));
		*/
		
		// Power test
		/*
		double rssi = Driver.convertToPower(-70);
		System.out.println("rssi: "+rssi);
		*/
		
		//Priority queue test
		/*PriorityQueue<Double> pq = new PriorityQueue<Double>(24, Collections.reverseOrder());
		pq.add(2.4);
		pq.add(1.2);
		pq.add(8.9);
		pq.add(3.6);
		
		System.out.println(pq.peek());*/
		
		/*
		PriorityQueue<Need> needs = new PriorityQueue<Need>((Utility.NUM_CHUNKS/2), new Comparator<Need>() {
			@Override
			public int compare(Need arg0, Need arg1) {
				return -arg0.sum.compareTo(arg1.sum);
			}
		});
		
		needs.add (new Need("",0,2.4));
		needs.add (new Need("",0,1.2));
		needs.add (new Need("",0,8.9));
		needs.add (new Need("",0,3.6));
		
		System.out.println(needs.poll().sum);
		System.out.println(needs.poll().sum);
		System.out.println(needs.poll().sum);
		System.out.println(needs.poll().sum);
		*/
		
		// IP Test
		String myIp = "";
		try {
			myIp = InetAddress.getLocalHost().getHostAddress();
		} catch (UnknownHostException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		System.out.println("myIp: "+myIp);
		
		// TODO: needs to be moved to some other thread
		try {
			
			// TCP Sockets (setup start)
			ServerSocket ss = new ServerSocket(LPORT);
			ss.setReuseAddress(true);
			Socket s = ss.accept(); // block until a new connection comes in
			
			TcpReceiver ts = new TcpReceiver(s);
			
			Chunk recvChunk = null;
			int numToRecv = 100;
			int numReceived = 0;
			long bytesRecv = 0;
			//ds.receive(recvPack); // intro packet to prompt time calculation
			long startTime = System.currentTimeMillis();
			System.out.println("Start time: "+startTime);
			Chunk temp = new Chunk("test", 0, 1024*8, "dest");

			//while (numReceived < 200) {
				for (int i=0; i<numToRecv; ++i) {
					//ds.receive(recvPack);
					numReceived++;
					//int length = recvPack.getLength();
					//recvChunk = (Chunk) Utility.deserialize(recvBuf, length);
					// System.out.println("Received a chunk of size: "+Utility.sizeOfSerial(recvChunk));
					
					recvChunk = (Chunk) ts.receive();
					System.out.println("Received packet # "+numReceived);
					long sz = Utility.sizeOfSerial(recvChunk);
					//System.out.println("Received a chunk of size: "+sz+" Bytes");
					
					//bytesRecv += length;
					bytesRecv += sz;

				}
			//}
			long endTime = System.currentTimeMillis();
			System.out.println("End time: "+endTime);
			long delta = endTime - startTime;
			double rate = ((double)bytesRecv) / (((double)delta)/1000);
			
			System.out.println("Received: "+bytesRecv+" Bytes");
			System.out.println("Rate: "+(rate/1024)+" KBytes/sec");
			
			//ds.close();
			
			ss.close();
			ts.close();
			
		} catch (IOException e) {
			System.err.println("Error initializing Socket");
			e.printStackTrace();
		}
		
	}
	
}
